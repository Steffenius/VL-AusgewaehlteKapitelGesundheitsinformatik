\section{De novo-Assemblierung}

Das Zusammensetzen der ursprünglichen vollständigen Nukleotidsequenz aus den Tausenden oder Millionen von Reads wird als \textbf{de novo-Assembly} bezeichnet. Wie bei einem Puzzle müssen dafür zunächst zwischen den Reads bzw. ihren Teilen Nachbarschaftsverhältnisse detektiert werden. Im Fall eines Puzzles wären das für jedes Teil die Nachbarschaft zu den vier umgebenden Teilen, beim Assembly ist es stattdessen die Überlappung zwischen aufeinanderfolgenden Reads. Diese Nachbarschaftsverhältnisse werden in der Regel in Graphen dargestellt. 

\subsection{Overlap-Graph}

Die intuitivste Darstellung ist die in einem \textbf{Overlap-Graph}. Hier ist jeder Read ein Knoten und jede \textbf{Überlappung} zwischen zwei Reads (also im einfachsten Fall die exakte Übereinstimmung der letzten N Basen eines Reads mit den ersten N Basen eines anderen Reads, bei realen fehlerbehafteten Datensätzen werden auch nicht-exakte Übereinstimmungen betrachtet) ist eine Kante zwischen den entsprechenden Knoten. Wird aus allen Reads eines Datensatzes ein Overlap-Graph erstellt, entspricht das ursprüngliche Genom einem Pfad durch diesen Graphen: Eine von mehreren aufeinanderfolgend überlappenden Reads dargestellte Sequenz kann rekonstruiert werden, indem die Sequenz des ersten Knotens bei jedem Schritt durch den Graph um die Basen erweitert wird, die durch den nächsten Knoten neu hinzukommen (wenn eine Kante von einem Knoten A eine Überlappung der Länge N zu einem Knoten B mit einem Read der Länge M zeigt, kann die Sequenz um M-N letzten Basen von Knoten B erweitert werden, da die überlappenden N Basen bereits in der Sequenz von Knoten A enthalten sind). 

Der Aufbau eines solchen Graphen ist allerdings Zeit- und Speicheraufwändig. Zunächst erfordert er einen paarweisen Vergleich aller Sequenzen. Insbesondere wenn nicht-exakte Überlappungen erlaubt werden, ist dies sehr zeitaufwändig. Zudem ist der Speicheraufwand proportional zur Größe des Datensatzes: Für jeden neuen Read muss mindestens ein neuer Knoten mit genug Speicherplatz für die Sequenz des Reads angelegt werden, in der Regel zusätzlich auch mehrere Kanten. Bei hunderte GB großen Datensätzen stellt das eine signifikante Herausforderung dar. 

Das Finden des richtigen Pfades durch den Overlap-Graph ist zudem nicht trivial und nicht immer möglich. Durch Sequenzierfehler können scheinbare Überlappungen zwischen Reads entstehen, die zu einer falschen Rekonstruktion führen. \textbf{Repetitive Sequenzen}\footnote{Fast alle Organismen enthalten unterschiedliche Stellen im Genom, deren Sequenzen einander sehr ähnlich oder gar identisch sind.} in den Genomen, die länger sind als ein Read, führen zu Verzweigungen im Graphen (mehrere unterschiedliche Reads überlappen mit den Reads aus der repetitiven Sequenz, da an unterschiedlichen Stellen das Genom hinter der repetitiven Sequenz unterschiedlich weitergeht), die nicht eindeutig aufgelöst werden können. 

\subsection{De Bruijn-Graph}

Eine Alternative zum Overlap-Graph stellt der \textbf{de Bruijn-Graph} dar. Allgemein ist es ein Graph, dessen Knoten Zeichenfolgen eines beliebigen Alphabets enthalten. Dabei ist ist die Zeichenfolge in jedem Knoten exakt gleich lang (diese Anzahl an Zeichen wird als die \textbf{Dimension des de Bruijn-Graphen} bezeichnet). Eine Kante existiert zwischen zwei Knoten eines de Bruijn-Graphen der Dimension N exakt dann, wenn die letzten N-1 Zeichen des einen Knotens identisch sind mit den ersten N-1 Zeichen des anderen Knotens. 

Für das de novo-Assembly können de Bruijn-Graphen nicht direkt aus den Reads erstellt werden - diese könnten unterschiedliche Längen haben und die Anforderung, zwei Reads sollten sich mit fast ihrer gesamten Länge überlappen, wäre extrem restriktiv. Stattdessen wird für den Aufbau des Graphen jeder Read in seine \textbf{k-mere} zerlegt: Es werden alle substrings der Länge k, welche in dem Read enthalten sind, generiert. Das bedeutet, dass ein Read der Länge N exakt N-k+1 k-mere (der Länge k) enthält, die sich jeweils um k-1 Basen überlappen. Dies passt exakt zu der Definition des de Bruijn-Graphen: Jedes k-mer ist gleich lang, kann also ein Knoten im Graphen sein. Zwischen jeden zwei sich um k-1 Basen überlappenden Knoten entsteht eine Kante, also sind alle k-mere eines Reads durch Kanten miteinander verbunden. 

Die Erstellung des de Bruijn-Graphen aus einem NGS-Datensatz ist deutlich einfacher, als die eines Overlap-Graphen. Es muss kein paarweiser Vergleich aller Reads erfolgen. Stattdesssen kann ein Index aller bisher im Graphen vorhandener k-mere gehalten werden. Wird ein neues k-mer hinzugefügt, können alle 8 mit dem Nukleotid-Alphabet von 4 Basen möglichen Überlappungen berechnet werden und es kann im Index abgefragt werden, ob einer dieser Knoten bereits im Graph existiert, was deutlich schneller ist als paarweise Read-Vergleiche. Zudem steigt der Speicherbedarf nicht mit der Anzahl an Reads im Datensatz sondern nur mit der Länge des zu rekonstruierenden Genoms: Sind alle k-mere des Genoms bereits im Graph enthalten, müssen beim Hinzufügen eines neuen Reads keine neuen Knoten mehr hinzugefügt werden, da alle in dem Read existierenden k-mere\footnote{Vorausgesetzt, der Read kommt aus diesen Genom und enthält keine Sequenzierfehler} bereits im Graph existieren. 

Das Finden des richtigen Pfades im de Bruijn-Graph ist allerdings leider ebenfalls nicht immer möglich. Repetitive Sequenzen sind noch problematischer als im Overlap-Graph, da sie hier nicht mehr aufgelöst werden können, wenn sie länger als die für den Aufbau des Graphen gewählte k-mer-Länge sind - unabhängig von der Read-Länge. Dort, wo keine Verzweigungen im Graph vorhanden sind, ist die Rekonstruktion allerdings ein trivialer Spezialfall der Rekonstruktion aus dem Overlap-Graph: Folgt man einer Kante von einem Knoten zum nächsten, muss die Sequenz nur um exakt die letzte Base des neuen Knotens erweitert werden, da die Überlappung immer exakt eine Base kürzer als die Sequenz der Knoten ist.

\subsection{Rekonstruktion aus dem Graph}

Sowohl im Fall des Overlap-Graphen als auch im Fall des de Bruijn-Graphen erfordert die Rekonstruktion der Genomsequenz zunächst eine Vereinfachung des Graphen. Beim Overlap-Graph müssen zunächst transitiv definierte Kanten entfernt werden\footnote{Wenn Knoten A mit B überlappt, und B mit C, kann es sein, dass auch ein kürzeres Stück von A mit C überlappt - diese Information ist redundant, da die Überlappung zwischen A und C sich aus den Sequenzlängen von A, B und C sowie der Überlappungslänge zwischen A und B sowie der zwischen B und C ergibt.}. Dann müssen in beiden Fällen Haare und Blasen entfernt werden. Haare entstehen durch Sequenzierfehler am Ende von Reads: Solche Reads führen zu Knoten (oder kurzen Knoten-Folgen), die nur auf der fehlerfrein Seite durch Kanten mit dem restlichen Graph verbunden sind, dort wo der Fehler enthalten ist aber keine weiteren Kanten mehr enthalten\footnote{Dies wird als Haare bezeichnet, da sie vom restlichen Graph wie Haare - nur an einer Seite verbunden - abstehen}. Blasen können durch Sequenzierfehler in der Mitte von Reads - wie Haare, die in der Mitte aufgrund des Fehlers keine Kanten zum restlichen Graph enthalten aber am Ende doch wieder in den Graph zurückführen - oder durch kleine Unterschiede in den sequenzierten Zellen entstehen.

Nach der Beseitigung von Haaren und Blasen bleiben nur noch lange Stränge von jeweils mit einer Kante miteinander verbundenen Knoten übrig, die sich an repetitiven Sequenzen in mehrere Stränge aufteilen oder wieder ineinander zusammenfließen. Diese Verzweigungen im Graph können, außer durch Erhöhung der Read- bzw. k-mer-Länge, nicht aufgelöst werden. Entsprechend rekonstruieren de novo-Assembler nur die Genomfragmente aus den eindeutigen Strängen von Knoten und geben diese einzeln als Teilsequenzen, genannt \textbf{Contigs}, aus. Die Reihenfolge der Contigs muss danach durch weitere Analysen und Laborexperimente geklärt werden. 

\subsection{Empfohlene Youtube-Videos}
\begin{description}[align=left]
	\item [Overlap-Graph] \href{https://www.youtube.com/watch?v=yPJ7yHRk2OI}{https://www.youtube.com/watch?v=yPJ7yHRk2OI}
	\item [De-Bruijn-Graph] \href{https://www.youtube.com/watch?v=TNYZZKrjCSk}{https://www.youtube.com/watch?v=TNYZZKrjCSk} (Eulerkreisproblem nur als theoretischer Hintergrund, nicht klausurrelevant)
	\item [Contigs] \href{https://www.youtube.com/watch?v=0Ho2\_\_cFsVY}{https://www.youtube.com/watch?v=0Ho2\_\_cFsVY}
	\item [Gesamtüberblick de novo-Assemblierung] \href{https://www.youtube.com/watch?v=V2xIGdEkA5U}{https://www.youtube.com/watch?v=V2xIGdEkA5U} (Enthält viel Zusatzinformation, aber für das Gesamtverständnis sehr schöne Präsentation)
\end{description}

\subsection{Kontrollfragen}
\begin{enumerate}
	\item Was ist die Aufgabe des de novo-Assemblies?
	\item Was ist ein k-mer?
	\item Weshalb kann beim DNA-Alphabet ein k-mer im de Bruijn-Graphen Kanten zu maximal 8 anderen Knoten haben?
	\item Weshalb können repetitive Sequenzen, die länger als die Read-Länge sind, weder mit Overlap- noch mit de Bruijn-Graphen aufgelöst werden?
\end{enumerate}
